#include "types.h"
#include "config.h"
#include "kiwi.h"
#include "rx.h"
#include "mem.h"
#include "misc.h"
#include "str.h"
#include "web.h"
#include "spi.h"
#include "coroutines.h"
#include "debug.h"
#include "printf.h"
#include "shmem.h"

#include <sys/file.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <setjmp.h>
#include <ctype.h>
#include <syslog.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <execinfo.h>

bool log_foreground_mode = false;
static bool log_ordinary_printfs = false;

void kiwi_exit_dont_use(int err)
{
    panic("don't use exit() -- use kiwi_exit() instead");
}

void kiwi_exit(int err)
{
	fflush(stdout);
	spin_ms(1000);	// needed for syslog messages to be properly recorded
	closelog();
    #undef exit
        exit(err);
    #define exit ALT_EXIT
}

void kiwi_backtrace(const char *id, u4_t printf_type)
{
    #define N_BTRACE 20
	void *fptr[N_BTRACE];
	int nr = backtrace(fptr, N_BTRACE);
	char **sptr = backtrace_symbols(fptr, nr);

	for (int i = 0; i < nr; i++) {
	    char *buf;
	    asprintf(&buf, "%s: backtrace %d %p %s\n", id, i, fptr[i], sptr[i]);
        if (background_mode || log_foreground_mode) {
            syslog(LOG_ERR, "%s", buf);
        }
        lfprintf(printf_type, "%s", buf);
        kiwi_asfree(buf);
	}
	kiwi_asfree(sptr);    // free just the array, not the individual strings (says the manpage)
}

void _panic(const char *str, bool coreFile, const char *file, int line)
{
	char *buf;
	
	if (ev_dump) ev(EC_DUMP_CONT, EV_PRINTF, -1, "panic", "dump");
	asprintf(&buf, "%s: \"%s\" (%s, line %d)", coreFile? "DUMP":"PANIC", str, file, line);

	if (background_mode || log_foreground_mode) {
		syslog(LOG_ERR, "%s\n", buf);
	}
	
	printf("%s\n", buf);
	kiwi_backtrace("panic");
	if (coreFile) abort();
	kiwi_exit(-1);
}

void _real_panic(const char *str, bool coreFile, const char *file, int line)
{
	char *buf;
	
	if (ev_dump) ev(EC_DUMP_CONT, EV_PRINTF, -1, "panic", "dump");
	asprintf(&buf, "%s: \"%s\" (%s, line %d)", coreFile? "DUMP":"PANIC", str, file, line);

	if (background_mode || log_foreground_mode) {
		syslog(LOG_ERR, "%s\n", buf);
	}
	
	real_printf("%s\n", buf);
	//kiwi_backtrace("panic");
	if (coreFile) abort();
	kiwi_exit(-1);
}

void _sys_panic(const char *str, const char *file, int line)
{
	char *buf;
	
	// errno might be overwritten if the malloc inside asprintf fails
	asprintf(&buf, "SYS_PANIC: \"%s\" %s (%s, line %d)", str, strerror(errno), file, line);

	if (background_mode || log_foreground_mode) {
		syslog(LOG_ERR, "%s %m\n", buf);
	}
	
	printf("%s %s\n", buf, strerror(errno));
	kiwi_backtrace("sys_panic");
	kiwi_exit(-1);
}

void _ll_printf_panic()
{
    real_printf("ll_printf log_save CORRUPTION\n");
    kiwi_exit(-1);
}

// NB: when debugging use real_printf() to avoid loops!
static bool need_newline;

void real_printf(const char *fmt, ...)
{
	char *buf = NULL;

	va_list ap;
	va_start(ap, fmt);
	vasprintf(&buf, fmt, ap);
	va_end(ap);

	need_newline = buf[strlen(buf)-1] != '\n';

    // remove our override and call the actual underlying printf
    #undef printf
        printf("%s", buf);
    #define printf ALT_PRINTF
    kiwi_asfree(buf);
}

static bool appending;
static char *buf, *last_s, *start_s, *holdover;
static int brem;

log_save_t *log_save_p;

void printf_init()
{
    // when msg generated by child task must use mmap'd buffer to communicate to parent task
    assert(shmem != NULL);
    log_save_p = &shmem->log_save;
    char *p = log_save_p->mem;
    for (int i = 0; i < N_LOG_SAVE; i++) {
        assert(p < log_save_p->endp);
        log_save_p->arr[i] = p;
        p += N_LOG_MSG_LEN;
    }
    log_save_p->magic = LOG_MAGIC;
    log_save_p->init = true;
    
    holdover = (char *) "";
}

#define N_HIGHLIGHT 2
static int highlight_sl[N_HIGHLIGHT];
char *highlight_s[N_HIGHLIGHT];

void printf_highlight(int which, const char *prefix)
{
    which = CLAMP(which, 0, N_HIGHLIGHT-1);
    kiwi_asfree(highlight_s[which]);
    highlight_sl[which] = strlen(prefix);
    if (highlight_sl[which]) highlight_s[which] = strdup(prefix);
}

static void ll_printf(u4_t type, conn_t *conn, const char *fmt, va_list ap)
{
	int i, n, sl;
	char *s, *cp;
	#define VBUF 1024

	if ((type & PRINTF_REAL) || !do_sdr) {
		vasprintf(&buf, fmt, ap);

		// remove our override and call the actual underlying printf
		#undef printf
			printf("%s%s", need_newline? "\n":"", buf);
			need_newline = false;
		#define printf ALT_PRINTF
		
		//evPrintf(EC_EVENT, EV_PRINTF, -1, "printf", buf);
	
		kiwi_asfree(buf);
		buf = NULL;
		return;
	}
	
	if (appending) {
		s = last_s;
	} else {
		brem = VBUF;
		if ((buf = (char*) kiwi_imalloc("ll_printf", VBUF)) == NULL)
			panic("log malloc");
		s = buf;
		start_s = s;
	}

	vsnprintf(s, brem, fmt, ap);
	sl = strlen(s);		// because vsnprintf returns length disregarding limit, not the actual length
	brem -= sl+1;
	
	cp = &s[sl-1];
	if (*cp != '\n' && brem && !(type & PRINTF_MSG)) {
		last_s = cp+1;
		appending = true;
		return;
	} else {
		appending = false;
	}
	
	// for logging, don't print an empty line at all
	if ((type & (PRINTF_REG | PRINTF_LOG)) && (!background_mode || strcmp(start_s, "\n") != 0)) {

		// Remove non-ASCII since "systemctl status" gives [blob] message
		// unlike "systemctl log" which prints correctly.
		// Seems to no longer be true, at least with Debian 11
		/*
            int sl = strlen(buf);
            for (i=0; i < sl; i++)
                if (buf[i] > 0x7f) buf[i] = '?';
		*/

		kstr_t *ks = NULL;
		bool want_logged = (type & PRINTF_LOG);
		
		// uptime
		u4_t up = timer_sec();
		u4_t sec = timer_ms() % 60000; up /= 60;
		u4_t min = up % 60; up /= 60;
		u4_t hr  = up % 24; up /= 24;
		u4_t days = up;
		if (days) {
			ks = kstr_asprintf(ks, "%dd:", days);
		}
        ks = kstr_asprintf(ks, "%02d:%02d:%s%.3f ", hr, min, (sec < 10000)? "0":"", (float) sec/1e3);
	
		// show state of all rx channels
		rx_chan_t *rx;
		char ch_stat[MAX_RX_CHANS + 3 + SPACE_FOR_NULL];
		for (rx = rx_channels, i=0; rx < &rx_channels[rx_chans]; rx++, i++) {
			ch_stat[i] = rx->busy? ((i > 9)? ('A'+i-10) : ('0'+i)) : '.';
		}
		ch_stat[i] = ' ';
		ch_stat[i+1] = '\0';
		ks = kstr_cat(ks, ch_stat);
		
		// show rx channel number if message is associated with a particular rx channel
        int chan = -1;
        if (conn && (conn->type == STREAM_WATERFALL || conn->type == STREAM_SOUND || conn->type == STREAM_EXT))
            chan = conn->rx_channel;
        if (conn == NULL || chan != -1) {
            for (i=0; i < rx_chans; i++) {
                ch_stat[i] = (conn != NULL && i == chan)? ((i > 9)? ('A'+i-10) : ('0'+i)) : ' ';
            }
            ch_stat[i] = '\0';
            ks = kstr_cat(ks, ch_stat);
        } else {
            ks = kstr_asprintf(ks, "%*s", rx_chans, stprintf("[%02d]", conn->self_idx));
        }
        
        char *sp = kstr_sp(ks);
		
		bool actually_log = ((want_logged && (background_mode || log_foreground_mode)) || log_ordinary_printfs);
		if (actually_log) {
			syslog(LOG_INFO, "%s %s", sp, buf);
		}
	
		char tb[CTIME_R_BUFSIZE];
		utc_ctime_r(tb);
		tb[CTIME_R_NL-5] = '\0';    // remove the year
		
		// remove our override and call the actual underlying printf
		#undef printf
		    bool color = highlight_sl[0]? (strncasecmp(buf, highlight_s[0], highlight_sl[0]) == 0) : false;
		    const char *color_s = CYAN " ";
		    if (!color) {
		        color = highlight_sl[1]? (strncasecmp(buf, highlight_s[1], highlight_sl[1]) == 0) : false;
		        color_s = YELLOW " ";
		    }
            printf("%s%s %s %c %s%.*s%s", need_newline? "\n":"", tb, sp, want_logged? 'L':' ',
                color? color_s : "", (int) strlen(buf)-1, buf, color? NONL : "\n");
            need_newline = false;
		#define printf ALT_PRINTF

		evPrintf(EC_EVENT, EV_PRINTF, -1, "printf", buf);

		#define DUMP_ORDINARY_PRINTFS TRUE
        // FIXME: synchronization problem
        
        log_save_t *ls = log_save_p;
        if (ls->magic != LOG_MAGIC || !ls->init) {
            _ll_printf_panic();
        }
        
        // Add to in-memory log used by admin page, handling printfs from child tasks via shared memory.
        // Can't use asprintf() because kiwi_ifree() can't be done by parent/child process when needed.
        // Would need a scavenging mechanism.
        
		if (ls && (DUMP_ORDINARY_PRINTFS || !background_mode || actually_log || log_ordinary_printfs)) {

            assert(ls->idx >= 0);
            if (ls->idx < N_LOG_SAVE) {
                // potential race: hope that Linux doesn't timeslice parent/child between idx use/increment
                s = ls->arr[ls->idx++];
                assert(s != NULL);
                assert(s < ls->endp);
                snprintf(s, N_LOG_MSG_LEN, "%s %s %c %s", tb, sp, want_logged? 'L':' ', buf);
                strcpy(&s[N_LOG_MSG_LEN-2], "\n");      // truncate msg
            } else {
                ls->not_shown++;
                
                // scroll second half of messages by one by rotating the buffer pointers
                char *t_arr = ls->arr[N_LOG_SAVE/2];
                for (i = N_LOG_SAVE/2 + 1; i < N_LOG_SAVE; i++) {
                    ls->arr[i-1] = ls->arr[i];
                }
                ls->arr[N_LOG_SAVE-1] = t_arr;

                s = ls->arr[N_LOG_SAVE-1];
                snprintf(s, N_LOG_MSG_LEN, "%s %s %c %s", tb, sp, want_logged? 'L':' ', buf);
                strcpy(&s[N_LOG_MSG_LEN-2], "\n");      // truncate msg
            }
		}

	    kstr_free(ks);
	}
	
	// attempt to selectively record message remotely
	if (type & PRINTF_MSG) {
	    conn_t *c;
		for (c = conns; c < &conns[N_CONNS]; c++) {
			if (!c->valid || (c->type != STREAM_ADMIN && c->type != STREAM_MFG) || c->mc == NULL)
				continue;
			break;
		}
		
		// there should only be one active admin connection
		if (c != &conns[N_CONNS]) {
		
		    // Transmit one line at a time. Holdover last unterminated output until next call.
            #define N_LINES 32
            char *r_buf;
            str_split_t lines[N_LINES];
            n = kiwi_split(buf, &r_buf, "\r\n", lines, N_LINES);

            for (i = 0; i < n; i++) {
                const char *leading_nl = "";
                if (i == 0 && buf[0] == '\n') leading_nl = "\n";
                else
                if (i == 0 && buf[0] == '\r') leading_nl = "\r";
                //real_printf("%d leading_nl='%s' <%s%s> delim='%s'\n", i, ASCII[buf[0]], leading_nl, lines[i].str, ASCII[lines[i].delim]);
                if (i == n-1 && lines[i].str[0] != '\0' && lines[i].delim == '\0') {
                    holdover = strdup(lines[i].str);
                    //real_printf("(holdover)\n");
                } else {
                    send_msg_encoded(c, "MSG", "output_msg", "%s%s%s%c",
                        (i == 0 && (type & PRINTF_FF))? "\f" : holdover, leading_nl, lines[i].str, lines[i].delim);
                    if (holdover[0] != '\0') {
                        free(holdover);
                        holdover = (char *) "";
                    }
                }
            }
            kiwi_ifree(r_buf, "llprintf r_buf");
        }
	}
	
	kiwi_ifree(buf, "ll_printf buf");
	buf = NULL;
}

void alt_printf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_REG, NULL, fmt, ap);
	va_end(ap);
}

void lfprintf(u4_t printf_type, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(printf_type, NULL, fmt, ap);
	va_end(ap);
}

void cprintf(conn_t *c, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_REG, c, fmt, ap);
	va_end(ap);
}

void clprintf(conn_t *c, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_LOG, c, fmt, ap);
	va_end(ap);
}

void clfprintf(conn_t *c, u4_t printf_type, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(printf_type, c, fmt, ap);
	va_end(ap);
}

void lprintf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_LOG, NULL, fmt, ap);
	va_end(ap);
}

void rcprintf(int rx_chan, const char *fmt, ...)
{
	conn_t *c = rx_channels[rx_chan].conn;

	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_REG, c, fmt, ap);
	va_end(ap);
}

void rclprintf(int rx_chan, const char *fmt, ...)
{
	conn_t *c = rx_channels[rx_chan].conn;

	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_LOG, c, fmt, ap);
	va_end(ap);
}

void rcfprintf(int rx_chan, u4_t printf_type, const char *fmt, ...)
{
	conn_t *c = rx_channels[rx_chan].conn;

	va_list ap;
	va_start(ap, fmt);
	ll_printf(printf_type, c, fmt, ap);
	va_end(ap);
}

void mprintf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_MSG, NULL, fmt, ap);
	va_end(ap);
}

void mprintf_ff(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_MSG|PRINTF_FF, NULL, fmt, ap);
	va_end(ap);
}

void mlprintf(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_MSG|PRINTF_LOG, NULL, fmt, ap);
	va_end(ap);
}

void mlprintf_ff(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	ll_printf(PRINTF_MSG|PRINTF_LOG|PRINTF_FF, NULL, fmt, ap);
	va_end(ap);
}

#define N_DST_STATIC 4
#define N_DST_STATIC_BUF (1024 + SPACE_FOR_NULL)
static char dst_static[N_DST_STATIC][N_DST_STATIC_BUF];

// result in a static buffer for use with e.g. a short-term immediate printf argument
// NB: not thread-safe
char *stnprintf(int which, const char *fmt, ...)
{
	if (fmt == NULL) return NULL;
	check(which < N_DST_STATIC);

	va_list ap;
	va_start(ap, fmt);
    vsnprintf(dst_static[which], N_DST_STATIC_BUF, fmt, ap);
    va_end(ap);

	return dst_static[which];
}

char *stprintf(const char *fmt, ...)
{
	if (fmt == NULL) return NULL;

	va_list ap;
	va_start(ap, fmt);
    vsnprintf(dst_static[0], N_DST_STATIC_BUF, fmt, ap);
    va_end(ap);

	return dst_static[0];
}

// asprintf(), but return value is pointer to allocated buffer.
// Easier to use in an arg list, but more difficult to free()
const char *aspf(const char *fmt, ...)
{
	char *s;

	va_list ap;
	va_start(ap, fmt);
    int vasprintf(char **strp, const char *fmt, va_list ap);    // #include def isn't found?
    vasprintf(&s, fmt, ap);
    va_end(ap);

	return (const char *) s;
}

// encoded snprintf()
int esnprintf(char *str, size_t slen, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	vsnprintf(str, slen, fmt, ap);
	va_end(ap);

	char *str2 = kiwi_str_encode(str);
	int slen2 = strlen(str2);
	
	// Passed sizeof str[slen] is meant to be far larger than current strlen(str)
	// so there is room to return the larger encoded result.
	check(slen2 <= slen);
	strcpy(str, str2);
	kiwi_ifree(str2, "esnprintf");

	return slen2;
}
